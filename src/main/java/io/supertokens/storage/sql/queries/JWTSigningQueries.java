/*
 *    Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.
 *
 *    This software is licensed under the Apache License, Version 2.0 (the
 *    "License") as published by the Apache Software Foundation.
 *
 *    You may not use this file except in compliance with the License. You may
 *    obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *    License for the specific language governing permissions and limitations
 *    under the License.
 */

package io.supertokens.storage.sql.queries;

import io.supertokens.pluginInterface.jwt.JWTAsymmetricSigningKeyInfo;
import io.supertokens.pluginInterface.jwt.JWTSigningKeyInfo;
import io.supertokens.pluginInterface.jwt.JWTSymmetricSigningKeyInfo;
import io.supertokens.storage.sql.Start;
import io.supertokens.storage.sql.config.Config;
import io.supertokens.storage.sql.domainobject.jwtsigning.JWTSigningDO;
import io.supertokens.storage.sql.hibernate.CustomQueryWrapper;
import io.supertokens.storage.sql.hibernate.CustomSessionWrapper;
import io.supertokens.storage.sql.utils.Utils;

import javax.persistence.LockModeType;
import java.sql.SQLException;
import java.util.List;
import java.util.stream.Collectors;

public class JWTSigningQueries {
    static String getQueryToCreateJWTSigningTable(Start start) {
        /*
         * created_at should only be used to determine the key that was added to the database last, it should not be
         * used to determine the validity or lifetime of a key. While the assumption that created_at refers to the time
         * the key was generated holds true for keys generated by the core, it is not guaranteed when we allow user
         * defined
         * keys in the future.
         */
        String schema = Config.getConfig(start).getTableSchema();
        String jwtSigningKeysTable = Config.getConfig(start).getJWTSigningKeysTable();
        // @formatter:off
        return "CREATE TABLE IF NOT EXISTS " + jwtSigningKeysTable + " ("
                + "key_id VARCHAR(255) NOT NULL,"
                + "key_string TEXT NOT NULL,"
                + "algorithm VARCHAR(10) NOT NULL,"
                + "created_at BIGINT,"
                + "CONSTRAINT " + Utils.getConstraintName(schema, jwtSigningKeysTable, null, "pkey") +
                " PRIMARY KEY(key_id));";
        // @formatter:on
    }

    public static List<JWTSigningKeyInfo> getJWTSigningKeys_Transaction(CustomSessionWrapper session)
            throws SQLException {
        String QUERY = "SELECT entity FROM JWTSigningDO entity ORDER BY entity.created_at DESC";

        CustomQueryWrapper<JWTSigningDO> q = session.createQuery(QUERY, JWTSigningDO.class);
        q.setLockMode(LockModeType.PESSIMISTIC_WRITE);

        return q.list().stream().map(result -> {
            if (result.getKey_string().contains("|")) {
                return new JWTAsymmetricSigningKeyInfo(result.getKey_id(), result.getCreated_at(),
                        result.getAlgorithm(), result.getKey_string());
            } else {
                return new JWTSymmetricSigningKeyInfo(result.getKey_id(), result.getCreated_at(), result.getAlgorithm(),
                        result.getKey_string());
            }
        }).collect(Collectors.toList());
    }

    public static void setJWTSigningKeyInfo_Transaction(CustomSessionWrapper session, JWTSigningKeyInfo info)
            throws SQLException {

        session.save(new JWTSigningDO(info.keyId, info.keyString, info.algorithm, info.createdAtTime));
    }
}
